Part 4: Allow Location Descriptions on the Stack

In Section 2.5 DWARF Expressions, add the following text at the end of
the section:

    --------------------------------------------------------------------
    A DWARF expression can either be encoded as an operation expression
    (see 2.5.x DWARF Operation Expressions), or as a location list
    expression (see 2.5.x DWARF Location List Expressions).
    --------------------------------------------------------------------

Rename the subsection 2.5.x General Operations:

    --------------------------------------------------------------------
    2.5.x DWARF Operation Expressions
    --------------------------------------------------------------------

Insert the following before the paragraph beginning “Operations can act
on entries on the stack...”:

    --------------------------------------------------------------------
    Each stack entry can hold either a value or a location description.
    --------------------------------------------------------------------

Insert the following after the same paragraph:

    --------------------------------------------------------------------
    If the kind of a stack entry does not match the kind required by the
    operation and is not implicitly convertible to the required kind
    (see 2.x.x.x Memory Location Description Operations), then the DWARF
    operation expression is ill-formed.
    --------------------------------------------------------------------

In Section 2.5.1.3 Stack Operations, insert the following at the end of
the first paragraph, following “Operations that index the stack assume
that the top of the stack (most recently added entry) has index 0”:

    --------------------------------------------------------------------
    They allow the stack entries to be either a value or location
    description.
    --------------------------------------------------------------------

Insert the following new paragraph after that paragraph:

    --------------------------------------------------------------------
    If any stack entry accessed by a stack operation is an incomplete
    composite location description (see 2.x.x Composite Location
    Description Operations), then the DWARF expression is ill-formed.
    --------------------------------------------------------------------

    > [For further discussion...]
    > If it is desired to also make them work with incomplete composite
    > location descriptions, then would need to define that the
    > composite location storage specified by the incomplete composite
    > location description is also replicated when a copy is pushed.
    > This ensures that each copy of the incomplete composite location
    > description can update the composite location storage they specify
    > independently.

In the description of DW_OP_deref_type, replace the paragraph beginning
“It pops one stack entry and treats it as an address...” with the
following:

    --------------------------------------------------------------------
    It pops one stack entry that must be a location description L.

    A value V of TS bits is retrieved from the location storage LS
    specified by one of the single location descriptions SL of L.

    [non-normative] If L, or the location description of any composite
    location description part that is a subcomponent of L, has more than
    one single location description, then any one of them can be
    selected as they are required to all have the same value. For any
    single location description SL, bits are retrieved from the
    associated storage location starting at the bit offset specified by
    SL. For a composite location description, the retrieved bits are the
    concatenation of the N bits from each composite location part PL,
    where N is limited to the size of PL.

    V is pushed on the stack with the type T.

    See 2.5.x.x Implicit Location Description Operations for special
    rules concerning implicit location descriptions created by the
    DW_OP_implicit_pointer operation.
    --------------------------------------------------------------------

In the description of DW_OP_xderef, replace the paragraph beginning “The
value V is retrieved from the location described by L...” with the
following:

    --------------------------------------------------------------------
    The operation is equivalent to popping A and AS, pushing L, and then
    performing DW_OP_deref. The value V retrieved is left on the stack
    with the generic type.
    --------------------------------------------------------------------

In the description of DW_OP_xderef_size, replace the paragraph beginning
“The value V of size S is retrieved from the location described by L...”
with the following:

    --------------------------------------------------------------------
    The operation is equivalent to popping A and AS, pushing L, and then
    performing DW_OP_deref_size S. The zero-extended value V retrieved
    is left on the stack with the generic type.
    --------------------------------------------------------------------

In the description of DW_OP_xderef_type, replace the paragraph beginning
“The value V is retrieved from the location described by L...” with the
following:

    --------------------------------------------------------------------
    The operation is equivalent to popping A and AS, pushing L, and then
    performing DW_OP_deref_type DR. The value V retrieved is left on the
    stack with the type T.
    --------------------------------------------------------------------

Replace the description of DW_OP_push_object_address with the following:

    --------------------------------------------------------------------
    DW_OP_push_object_address pushes the location description L of the
    current object.

    [non-normative] This object may correspond to an independent
    variable that is part of a user presented expression that is being
    evaluated. The object location description may be determined from
    the variable’s own debugging information entry or it may be a
    component of an array, structure, or class whose address has been
    dynamically determined by an earlier step during user expression
    evaluation.

    [non-normative] This operation provides explicit functionality
    (especially for arrays involving descriptors) that is analogous to
    the implicit push of the base location description of a structure
    prior to evaluation of a DW_AT_data_member_location to access a data
    member of a structure.

    > [For further discussion...]
    > This operation could be removed and the object location
    > description specified as the initial stack as for
    > DW_AT_data_member_location.
    >
    > Or this operation could be used instead of needing to specify an
    > initial stack. The latter approach is more composable as access to
    > the object may be needed at any point of the expression, and
    > passing it as the initial stack requires the entire expression to
    > be aware where on the stack it is. If this were done,
    > DW_AT_use_location would require a DW_OP_push_object2_address
    > operation for the second object.
    >
    > Or a more general way to pass an arbitrary number of arguments in
    > and an operation to get the Nth one such as DW_OP_arg N. A vector
    > of arguments would then be passed in the expression context rather
    > than an initial stack. This could also resolve the issues with
    > DW_OP_call* by allowing a specific number of arguments passed in
    > and returned to be specified. The DW_OP_call* operation could then
    > always execute on a separate stack: the number of arguments would
    > be specified in a new call operation and taken from the callers
    > stack, and similarly the number of return results specified and
    > copied from the called stack back to the callee stack when the
    > called expression was complete.
    >
    > The only attribute that specifies a current object is
    > DW_AT_data_location so the non-normative text seems to overstate
    > how this is being used. Or are there other attributes that need to
    > state they pass an object?
    --------------------------------------------------------------------

In Section 2.6.1.1.2 (now 2.6.2), add the following after the first
paragraph:

    --------------------------------------------------------------------
    If a stack entry is required to be a location description, but it is
    a value V with the generic type, then it is implicitly converted to
    a location description L with one memory location description SL. SL
    specifies the memory location storage that corresponds to the target
    architecture default address space with a bit offset equal to V
    scaled by 8 (the byte size).

    > [For further discussion...]
    > If it is wanted to allow any integral type value to be implicitly
    > converted to a memory location description in the target
    > architecture default address space:
    >
    >   If a stack entry is required to be a location description, but
    >   is a value V with an integral type, then it is implicitly
    >   converted to a location description L with a one memory
    >   location description SL. If the type size of V is less than
    >   the generic type size, then the value V is zero extended to
    >   the size of the generic type. The least significant generic
    >   type size bits are treated as an unsigned value to be used as
    >   an address A. SL specifies memory location storage
    >   corresponding to the target architecture default address space
    >   with a bit offset equal to A scaled by 8 (the byte size).
    >
    > The implicit conversion could also be defined as target
    > architecture specific. For example, GDB checks if V is an integral
    > type. If it is not it gives an error. Otherwise, GDB zero-extends
    > V to 64 bits. If the GDB target defines a hook function, then it
    > is called. The target specific hook function can modify the 64-bit
    > value, possibly sign extending based on the original value type.
    > Finally, GDB treats the 64-bit value V as a memory location
    > address.

    If a stack entry is required to be a location description, but it is
    an implicit pointer value IPV with the target architecture default
    address space, then it is implicitly converted to a location
    description with one single location description specified by IPV.
    See 2.5.4.4.5 Implicit Location Description Operations.

    If a stack entry is required to be a value, but it is a location
    description L with one memory location description SL in the target
    architecture default address space with a bit offset B that is a
    multiple of 8, then it is implicitly converted to a value equal to B
    divided by 8 (the byte size) with the generic type.
    --------------------------------------------------------------------

In Section 2.5.1.1 Literal Encodings, replace the description of
DW_OP_addr with the following:

    --------------------------------------------------------------------
    DW_OP_addr has a single byte constant value operand, which has the
    size of the generic type, that represents an address A.

    It pushes a location description L with one memory location
    description SL on the stack. SL specifies the memory location
    storage corresponding to the target architecture default address
    space with a bit offset equal to A scaled by 8 (the byte size).

    [non-normative] If the DWARF is part of a code object, then A may
    need to be relocated. For example, in the ELF code object format, A
    must be adjusted by the difference between the ELF segment virtual
    address and the virtual address at which the segment is loaded.
    --------------------------------------------------------------------

In the same section, replace the description of DW_OP_addrx with the
following:

    --------------------------------------------------------------------
    DW_OP_addrx has a single unsigned LEB128 integer operand that
    represents a zero-based index into the .debug_addr section relative
    to the value of the DW_AT_addr_base attribute of the associated
    compilation unit. The address value A in the .debug_addr section has
    the size of the generic type.

    It pushes a location description L with one memory location
    description SL on the stack. SL specifies the memory location
    storage corresponding to the target architecture default address
    space with a bit offset equal to A scaled by 8 (the byte size).

    [non-normative] If the DWARF is part of a code object, then A may
    need to be relocated. For example, in the ELF code object format, A
    must be adjusted by the difference between the ELF segment virtual
    address and the virtual address at which the segment is loaded.
    --------------------------------------------------------------------

In Section 2.5.1.3 Stack Operations, replace the first paragraph of the
description of DW_OP_form_tls_address with the following:

    --------------------------------------------------------------------
    DW_OP_form_tls_address pops one stack entry that must be an integral
    type value and treats it as a thread-local storage address TA.

    It pushes a location description L with one memory location
    description SL on the stack. SL is the target architecture specific
    memory location description that corresponds to the thread-local
    storage address TA.

    The meaning of the thread-local storage address TA is defined by the
    run-time environment. If the run-time environment supports multiple
    thread-local storage blocks for a single thread, then the block
    corresponding to the executable or shared library containing this
    DWARF expression is used.
    --------------------------------------------------------------------

In the same section, replace the first paragraph of the description of
DW_OP_call_frame_cfa with the following:

    --------------------------------------------------------------------
    DW_OP_call_frame_cfa pushes the location description L of the
    Canonical Frame Address (CFA) of the current subprogram, obtained
    from the call frame information on the stack. (See Section 6.4 Call
    Frame Information.)
    --------------------------------------------------------------------

In Section 2.5.1.2 Register Values, replace the description of
DW_OP_fbreg with the following:

    --------------------------------------------------------------------
    DW_OP_fbreg has a single signed LEB128 integer operand that
    represents a byte displacement B.

    The location description L for the frame base of the current
    subprogram is obtained from the DW_AT_frame_base attribute of the
    debugger information entry corresponding to the current subprogram
    as described in 3.3.5 Low-Level Information.

    The location description L is updated by bit offset B scaled by 8
    (the byte size) and pushed on the stack.
    --------------------------------------------------------------------

In the same section, replace the description of
DW_OP_breg0...DW_OP_breg31 with the following:

    --------------------------------------------------------------------
    The DW_OP_breg<N> operations encode the numbers of up to 32
    registers, numbered from 0 through 31, inclusive. The register
    number R corresponds to the N in the operation name.

    They have a single signed LEB128 integer operand that represents a
    byte displacement B.

    The address space identifier AS is defined as the one corresponding
    to the target architecture specific default address space.

    The address size S is defined as the address bit size of the target
    architecture specific address space corresponding to AS.

    The contents of the register specified by R are retrieved as if a
    DW_OP_regval_type R, DR operation was performed where DR is the
    offset of a hypothetical debug information entry in the current
    compilation unit for an unsigned integral base type of size S bits.
    B is added and the least significant S bits are treated as an
    unsigned value to be used as an address A.

    They push a location description L comprising one memory location
    description LS on the stack. LS specifies the memory location
    storage that corresponds to AS with a bit offset equal to A scaled
    by 8 (the byte size).
    --------------------------------------------------------------------

In Section 2.6.1.1.3 (now 2.6.3) Register Location Descriptions, replace
the description of DW_OP_regx with the following:

    --------------------------------------------------------------------
    DW_OP_regx has a single unsigned LEB128 integer operand that
    represents a target architecture register number R.

    If the current call frame is the top call frame, it pushes a
    location description L that specifies one register location
    description SL on the stack. SL specifies the register location
    storage that corresponds to R with a bit offset of 0 for the current
    thread.

    If the current call frame is not the top call frame, call frame
    information (see 6.4 Call Frame Information) is used to determine
    the location description that holds the register for the current
    call frame and current program location of the current thread. The
    resulting location description L is pushed.

    [non-normative] Note that if call frame information is used, the
    resulting location description may be register, memory, or
    undefined.

    [non-normative] An implementation may evaluate the call frame
    information immediately, or may defer evaluation until L is accessed
    by an operation. If evaluation is deferred, R and the current
    context can be recorded in L. When accessed, the recorded context is
    used to evaluate the call frame information, not the current context
    of the access operation.
    --------------------------------------------------------------------

In Section 2.6.1.1.4 (now 2.6.4) Implicit Location Descriptions, in the
first paragraph, replace “either known or known to be undefined” with
“known, either as a constant or by computations on other locations and
values in the program.” Add the following paragraph after the first:

    --------------------------------------------------------------------
    An implicit location description specifies an implicit location
    storage. The bit offset corresponds to a bit position within the
    implicit location storage. Bits accessed using an implicit location
    description, access the corresponding implicit storage value
    starting at the bit offset.
    --------------------------------------------------------------------

Replace the description of DW_OP_implicit_value with the following:

    --------------------------------------------------------------------
    DW_OP_implicit_value has two operands. The first is an unsigned
    LEB128 integer that represents a byte size S. The second is a block
    of bytes with a length equal to S treated as a literal value V.

    An implicit location storage LS is created with the literal value V
    and a size of S.

    It pushes location description L with one implicit location
    description SL on the stack. SL specifies LS with a bit offset of 0.
    --------------------------------------------------------------------

Replace the description of DW_OP_stack_value with the following:

    --------------------------------------------------------------------
    DW_OP_stack_value pops one stack entry that must be a value V.

    An implicit location storage LS is created with the literal value V
    using the size, encoding, and enianity specified by V’s base type.

    It pushes a location description L with one implicit location
    description SL on the stack. SL specifies LS with a bit offset of 0.

    The DW_OP_stack_value operation specifies that the object does not
    exist in memory, but its value is nonetheless known. In this form,
    the location description specifies the actual value of the object,
    rather than specifying the memory or register storage that holds the
    value.

    See DW_OP_implicit_pointer (following) for special rules concerning
    implicit pointer values produced by dereferencing implicit location
    descriptions created by the DW_OP_implicit_pointer operation.

    Note: Since location descriptions are allowed on the stack, the
    DW_OP_stack_value operation no longer terminates the DWARF operation
    expression execution as in DWARF Version 5.
    --------------------------------------------------------------------

Replace the description of DW_OP_implicit_pointer with the following:

    --------------------------------------------------------------------
    [unchanged] [non-normative] An optimizing compiler may eliminate a
    pointer, while still retaining the value that the pointer addressed.
    DW_OP_implicit_pointer allows a producer to describe this value.

    [non-normative] DW_OP_implicit_pointer specifies an object is a
    pointer to the target architecture default address space that cannot
    be represented as a real pointer, even though the value it would
    point to can be described. In this form, the location description
    specifies a debugging information entry that represents the actual
    location description of the object to which the pointer would point.
    Thus, a consumer of the debug information would be able to access
    the dereferenced pointer, even when it cannot access the pointer
    itself.

    DW_OP_implicit_pointer has two operands. The first operand is a
    4-byte unsigned value in the 32-bit DWARF format, or an 8-byte
    unsigned value in the 64-bit DWARF format, that represents the byte
    offset DR of a debugging information entry D relative to the
    beginning of the .debug_info section that contains the current
    compilation unit. The second operand is a signed LEB128 integer that
    represents a byte displacement B.

    [non-normative] Note that D might not be in the current compilation
    unit.

    [non-normative] The first operand interpretation is exactly like
    that for DW_FORM_ref_addr.

    The address space identifier AS is defined as the one corresponding
    to the target architecture specific default address space.

    The address size S is defined as the address bit size of the target
    architecture specific address space corresponding to AS.

    An implicit location storage LS is created with the debugging
    information entry D, address space AS, and size of S.

    It pushes a location description L that comprises one implicit
    location description SL on the stack. SL specifies LS with a bit
    offset of 0.

    It is an evaluation error if a DW_OP_deref* operation pops a
    location description L’, and retrieves S bits, such that any
    retrieved bits come from an implicit location storage that is the
    same as LS, unless both the following conditions are met:

     1. All retrieved bits come from an implicit location description
        that refers to an implicit location storage that is the same as
        LS.

        [non-normative] Note that all bits do not have to come from the
        same implicit location description, as L’ may involve composite
        location descriptors.

     2. The bits come from consecutive ascending offsets within their
        respective implicit location storage.

    [non-normative] These rules are equivalent to retrieving the
    complete contents of LS.

    If both the above conditions are met, then the value V pushed by the
    DW_OP_deref* operation is an implicit pointer value IPV with a
    target architecture specific address space of AS, a debugging
    information entry of D, and a base type of T. If AS is the target
    architecture default address space, then T is the generic type.
    Otherwise, T is a target architecture specific integral type with a
    bit size equal to S.

    If IPV is either implicitly converted to a location description
    (only done if AS is the target architecture default address space),
    then the resulting location description RL is:

      * If D has a DW_AT_location attribute, the DWARF expression E from
        the DW_AT_location attribute is evaluated with the current
        context, except that the result kind is a location description,
        the compilation unit is the one that contains D, the object is
        unspecified, and the initial stack is empty. RL is the
        expression result.

        [non-normative] Note that E is evaluated with the context of the
        expression accessing IPV, and not the context of the expression
        that contained the DW_OP_implicit_pointer operation that created
        L.

      * If D has a DW_AT_const_value attribute, then an implicit
        location storage RLS is created from the DW_AT_const_value
        attribute’s value with a size matching the size of the
        DW_AT_const_value attribute’s value. RL comprises one implicit
        location description SRL. SRL specifies RLS with a bit offset of
        0.

        NOTE: If using DW_AT_const_value for variables and formal
        parameters is deprecated and instead DW_AT_location is used with
        an implicit location description, then this rule would not be
        required.

      * Otherwise, it is an evaluation error.

    The location description RL is updated by bit offset B scaled by 8
    (the byte size).

    If a DW_OP_stack_value operation pops a value that is the same as
    IPV, then it pushes a location description that is the same as L.

    It is an evaluation error if LS or IPV is accessed in any other
    manner.

    [non-normative] The restrictions on how an implicit pointer location
    description created by DW_OP_implicit_pointer can be used are to
    simplify the DWARF consumer. Similarly, for an implicit pointer
    value created by DW_OP_deref* and DW_OP_stack_value.

    [non-normative] Typically a DW_OP_implicit_pointer operation is used
    in a DWARF expression E1 of a DW_TAG_variable or
    DW_TAG_formal_parameter debugging information entry D1’s
    DW_AT_location attribute. The debugging information entry referenced
    by the DW_OP_implicit_pointer operation is typically itself a
    DW_TAG_variable or DW_TAG_formal_parameter debugging information
    entry D2 whose DW_AT_location attribute gives a second DWARF
    expression E2.

    [non-normative] D1 and E1 are describing the location of a pointer
    type object. D2 and E2 are describing the location of the object
    pointed to by that pointer object.

    [non-normative] However, D2 may be any debugging information entry
    that contains a DW_AT_location or DW_AT_const_value attribute (for
    example, DW_TAG_dwarf_procedure). By using E2, a consumer can
    reconstruct the value of the object when asked to dereference the
    pointer described by E1 which contains the DW_OP_implicit_pointer
    operation.
    --------------------------------------------------------------------

Replace the contents of Section 2.6.1.2 (now 2.6.5) Composite Location
Descriptions with the following:

    --------------------------------------------------------------------
    A composite location storage represents an object or value which may
    be contained in part of another location storage or contained in
    parts of more than one location storage.

    Each part has a part location description L and a part bit size S. L
    can have one or more single location descriptions SL. If there are
    more than one SL then that indicates that part is located in more
    than one place. The bits of each place of the part comprise S
    contiguous bits from the location storage LS specified by SL
    starting at the bit offset specified by SL. All the bits must be
    within the size of LS or the DWARF expression is ill-formed.

    A composite location storage can have zero or more parts. The parts
    are contiguous such that the zero-based location storage bit index
    will range over each part with no gaps between them. Therefore, the
    size of a composite location storage is the sum of the size of its
    parts. The DWARF expression is ill-formed if the size of the
    contiguous location storage is larger than the size of the memory
    location storage corresponding to the largest target architecture
    specific address space.

    A composite location description specifies a composite location
    storage. The bit offset corresponds to a bit position within the
    composite location storage.

    There are operations that create a composite location storage.

    There are other operations that allow a composite location storage
    to be incrementally created. Each part is created by a separate
    operation. There may be one or more operations to create the final
    composite location storage. A series of such operations describes
    the parts of the composite location storage that are in the order
    that the associated part operations are executed.

    To support incremental creation, a composite location storage can be
    in an incomplete state. When an incremental operation operates on an
    incomplete composite location storage, it adds a new part.

    A composite location description that specifies a composite location
    storage that is incomplete is termed an incomplete composite
    location description. A composite location description that
    specifies a composite location storage that is complete is termed a
    complete composite location description.

    If the top stack entry is a location description that has one
    incomplete composite location description SL after the execution of
    an operation expression has completed, SL is converted to a complete
    composite location description.

    [non-normative] Note that this conversion does not happen after the
    completion of an operation expression that is evaluated on the same
    stack by the DW_OP_call* operations. Such executions are not a
    separate evaluation of an operation expression, but rather the
    continued evaluation of the same operation expression that contains
    the DW_OP_call* operation.

    If a stack entry is required to be a location description L, but L
    has an incomplete composite location description, then the DWARF
    expression is ill-formed. The exception is for the operations
    involved in incrementally creating a composite location description
    as described below.

    [non-normative] Note that a DWARF operation expression may
    arbitrarily compose composite location descriptions from any other
    location description, including those that have multiple single
    location descriptions, and those that have composite location
    descriptions.

    [non-normative] The incremental composite location description
    operations are defined to be compatible with the definitions in
    DWARF Version 5.

     1. DW_OP_piece

        DW_OP_piece has a single unsigned LEB128 integer that represents
        a byte size S.

        The action is based on the context:

          * If the stack is empty, then a location description L
            comprised of one incomplete composite location description
            SL is pushed on the stack.

            An incomplete composite location storage LS is created with
            a single part P. P specifies a location description PL and
            has a bit size of S scaled by 8 (the byte size). PL is
            comprised of one undefined location description PSL.

            SL specifies LS with a bit offset of 0.

          * Otherwise, if the top stack entry is a location description
            L comprised of one incomplete composite location description
            SL, then the incomplete composite location storage LS that
            SL specifies is updated to append a new part P. P specifies
            a location description PL and has a bit size of S scaled by
            8 (the byte size). PL is comprised of one undefined location
            description PSL. L is left on the stack.

          * Otherwise, if the top stack entry is a location description
            or can be converted to one, then it is popped and treated as
            a part location description PL. Then:

              * If the top stack entry (after popping PL) is a location
                description L comprised of one incomplete composite
                location description SL, then the incomplete composite
                location storage LS that SL specifies is updated to
                append a new part P. P specifies the location
                description PL and has a bit size of S scaled by 8 (the
                byte size). L is left on the stack.

              * Otherwise, a location description L comprised of one
                incomplete composite location description SL is pushed
                on the stack.

                An incomplete composite location storage LS is created
                with a single part P. P specifies the location
                description PL and has a bit size of S scaled by 8 (the
                byte size).

                SL specifies LS with a bit offset of 0.

          * Otherwise, the DWARF expression is ill-formed

        [non-normative] Many compilers store a single variable in sets
        of registers or store a variable partially in memory and
        partially in registers. DW_OP_piece provides a way of describing
        where a part of a variable is located.

        [non-normative] The evaluation rules for the DW_OP_piece
        operation allow it to be compatible with the DWARF Version 5
        definition.

        > [For further discussion...]
        > Since these extensions allow location descriptions to be
        > entries on the stack, a simpler operation to create composite
        > location descriptions could be defined. For example, just one
        > operation that specifies how many parts, and pops pairs of
        > stack entries for the part size and location description. Not
        > only would this be a simpler operation and avoid the
        > complexities of incomplete composite location descriptions,
        > but it may also have a smaller encoding in practice. However,
        > the desire for compatibility with DWARF Version 5 is likely a
        > stronger consideration.

     2. DW_OP_bit_piece

        DW_OP_bit_piece has two operands. The first is an unsigned
        LEB128 integer that represents the part bit size S. The second
        is an unsigned LEB128 integer that represents a bit displacement
        B.

        The action is the same as for DW_OP_piece, except that any part
        created has the bit size S, and the location description PL of
        any created part is updated by a bit offset B.

        [non-normative] DW_OP_bit_piece is used instead of DW_OP_piece
        when the piece to be assembled is not byte-sized or is not at
        the start of the part location description.
    --------------------------------------------------------------------

In Section 2.6.2 (now 2.6.6) Location Lists, insert the following at the
beginning of the section:

    --------------------------------------------------------------------
    [non-normative] To meet the needs of recent computer architectures
    and optimization techniques, debugging information must be able to
    describe the location of an object whose location changes over the
    object’s lifetime, and may reside at multiple locations during parts
    of an object’s lifetime. Location list expressions are used in place
    of operation expressions whenever the object whose location is being
    described has these requirements.
    --------------------------------------------------------------------

Remove the second and third paragraphs (“A location list is indicated
by...” and “This location list representation, the loclist class, ...”).

Replace the text of Item 1, Bounded location description, with the
following:

    --------------------------------------------------------------------
    This kind of location list entry provides an operation expression
    that evaluates to the location description of an object that is
    valid over a lifetime bounded by a starting and ending address. The
    starting address is the lowest address of the address range over
    which the location is valid. The ending address is the address of
    the first location past the highest address of the address range.

    The location list entry matches when the current program location is
    within the given range.

    There are several kinds of bounded location description entries
    which differ in the way that they specify the starting and ending
    addresses.
    --------------------------------------------------------------------

In the text of Item 2, Default location description, replace “provides a
location description that specifies the location of an object that is
valid when no bounded location description applies” with “provides an
operation expression that evaluates to the location description of an
object that is valid when no bounded location description entry
applies.”

In the text of Item 4, End-of-list, replace “location list” with
“location list expression.”

Insert the following before the paragraph beginning “A location list
consists of a sequence...”:

    --------------------------------------------------------------------
    The address ranges defined by the bounded location description
    entries of a location list expression may overlap. When they do,
    they describe a situation in which an object exists simultaneously
    in more than one place.

    If all of the address ranges in a given location list expression do
    not collectively cover the entire range over which the object in
    question is defined, and there is no following default location
    description entry, it is assumed that the object is not available
    for the portion of the range that is not covered.

    The result of the evaluation of a DWARF location list expression is:

      * If the current program location is not specified, then it is an
        evaluation error.

        > [For further discussion...]
        > If the location list only has a single default entry, should
        > that be considered a match if there is no program location? If
        > there are non-default entries then it seems it has to be an
        > evaluation error when there is no program location as that
        > indicates the location depends on the program location which
        > is not known.

      * If there are no matching location list entries, then the result
        is a location description that comprises one undefined location
        description.

      * Otherwise, the operation expression E of each matching location
        list entry is evaluated with the current context, except that
        the result kind is a location description, the object is
        unspecified, and the initial stack is empty. The location list
        entry result is the location description returned by the
        evaluation of E.

        The result is a location description that is comprised of the
        union of the single location descriptions of the location
        description result of each matching location list entry.

    A location list expression can only be used as the value of a
    debugger information entry attribute that is encoded using class
    loclist or loclistsptr (see 7.5.5 Classes and Forms). The value of
    the attribute provides an index into a separate object file section
    called .debug_loclists or .debug_loclists.dwo (for split DWARF
    object files) that contains the location list entries.

    A DW_OP_call* and DW_OP_implicit_pointer operation can be used to
    specify a debugger information entry attribute that has a location
    list expression. Several debugger information entry attributes allow
    DWARF expressions that are evaluated with an initial stack that
    includes a location description that may originate from the
    evaluation of a location list expression.

    [non-normative] This location list representation, the loclist and
    loclistsptr class, and the related DW_AT_loclists_base attribute are
    new in DWARF Version 5. Together they eliminate most, or all of the
    code object relocations previously needed for location list
    expressions.
    --------------------------------------------------------------------

In Section 3.3.5 Low Level Information, replace the first paragraph
(re. DW_AT_return_addr) with the following:

    --------------------------------------------------------------------
    A DW_TAG_subprogram, DW_TAG_inlined_subroutine, or
    DW_TAG_entry_point debugger information entry may have a
    DW_AT_return_addr attribute, whose value is a DWARF expression E.

    The result of the attribute is obtained by evaluating E with a
    context that has a result kind of a location description, an
    unspecified object, the compilation unit that contains E, an empty
    initial stack, and other context elements corresponding to the
    source language thread of execution upon which the user is focused,
    if any. The result of the evaluation is the location description L
    of the place where the return address for the current call frame’s
    subprogram or entry point is stored.

    The DWARF is ill-formed if L is not comprised of one memory location
    description for one of the target architecture specific address
    spaces.
    --------------------------------------------------------------------

    > [For further discussion...]
    > NOTE: It is unclear why DW_TAG_inlined_subroutine has a
    > DW_AT_return_addr attribute but not a DW_AT_frame_base or
    > DW_AT_static_link attribute. Seems it would either have all of
    > them or none. Since inlined subprograms do not have a call frame
    > it seems they would have none of these attributes.

Replace the second and third paragraphs (re. DW_AT_frame_base) with the
following:

    --------------------------------------------------------------------
    A DW_TAG_subprogram or DW_TAG_entry_point debugger information entry
    may have a DW_AT_frame_base attribute, whose value is a DWARF
    expression E.

    The result of the attribute is obtained by evaluating E with a
    context that has a result kind of a location description, an
    unspecified object, the compilation unit that contains E, an empty
    initial stack, and other context elements corresponding to the
    source language thread of execution upon which the user is focused,
    if any.

    The DWARF is ill-formed if E contains a DW_OP_fbreg operation, or
    the resulting location description L is not comprised of one single
    location description SL.

    If SL is a register location description for register R, then L is
    replaced with the result of evaluating a DW_OP_bregx R, 0 operation.
    This computes the frame base memory location description in the
    target architecture default address space.

    This allows the more compact DW_OP_reg* to be used instead of
    DW_OP_breg* 0.

    > [For further discussion...]
    > This rule could be removed and require the producer to create the
    > required location description directly using DW_OP_call_frame_cfa
    > or DW_OP_breg*. This would also then allow a target to implement
    > the call frames within a large register.

    Otherwise, the DWARF is ill-formed if SL is not a memory location
    description in any of the target architecture specific address
    spaces.

    The resulting L is the frame base for the subprogram or entry point.

    Typically, E will use the DW_OP_call_frame_cfa operation or be a
    stack pointer register plus or minus some offset.
    --------------------------------------------------------------------

Replacce the paragraph beginning "If a subroutine or entry point is
nested, ..." with the following:

    --------------------------------------------------------------------
    If a DW_TAG_subprogram or DW_TAG_entry_point debugger information
    entry is lexically nested, it may have a DW_AT_static_link
    attribute, whose value is a DWARF expression E.

    The result of the attribute is obtained by evaluating E with a
    context that has a result kind of a location description, an
    unspecified object, the compilation unit that contains E, an empty
    initial stack, and other context elements corresponding to the
    source language thread of execution upon which the user is focused,
    if any. The result of the evaluation is the location description L
    of the canonical frame address (see 6.4 Call Frame Information) of
    the relevant call frame of the subprogram instance that immediately
    lexically encloses the current call frame’s subprogram or entry
    point.

    The DWARF is ill-formed if L is is not comprised of one memory
    location description for one of the target architecture specific
    address spaces.
    --------------------------------------------------------------------


In Section 3.4.2 Call Site Parameters, replace the entire contents of
the section with the following...

    > [For further discussion...]
    > Keep first paragraph of 3.4.2?

    --------------------------------------------------------------------
    A DW_TAG_call_site_parameter debugger information entry may have a
    DW_AT_call_value attribute, whose value is a DWARF operation
    expression E1.

    The result of the DW_AT_call_value attribute is obtained by
    evaluating E1 with a context that has a result kind of a value, an
    unspecified object, the compilation unit that contains E, an empty
    initial stack, and other context elements corresponding to the
    source language thread of execution upon which the user is focused,
    if any. The resulting value V1 is the value of the parameter at the
    time of the call made by the call site.

    For parameters passed by reference, where the code passes a pointer
    to a location which contains the parameter, or for reference type
    parameters, the DW_TAG_call_site_parameter debugger information
    entry may also have a DW_AT_call_data_location attribute whose value
    is a DWARF operation expression E2, and a DW_AT_call_data_value
    attribute whose value is a DWARF operation expression E3.

    The value of the DW_AT_call_data_location attribute is obtained by
    evaluating E2 with a context that has a result kind of a location
    description, an unspecified object, the compilation unit that
    contains E, an empty initial stack, and other context elements
    corresponding to the source language thread of execution upon which
    the user is focused, if any. The resulting location description L2
    is the location where the referenced parameter lives during the call
    made by the call site. If E2 would just be a
    DW_OP_push_object_address, then the DW_AT_call_data_location
    attribute may be omitted.

    > [For further discussion...]
    > The DWARF Version 5 implies that DW_OP_push_object_address may be
    > used but does not state what object must be specified in the
    > context. Either DW_OP_push_object_address cannot be used, or the
    > object to be passed in the context must be defined.

    The value of the DW_AT_call_data_value attribute is obtained by
    evaluating E3 with a context that has a result kind of a value, an
    unspecified object, the compilation unit that contains E, an empty
    initial stack, and other context elements corresponding to the
    source language thread of execution upon which the user is focused,
    if any. The resulting value V3 is the value in L2 at the time of the
    call made by the call site.

    The result of these attributes is undefined if the current call
    frame is not for the subprogram containing the
    DW_TAG_call_site_parameter debugger information entry or the current
    program location is not for the call site containing the
    DW_TAG_call_site_parameter debugger information entry in the current
    call frame.

    [non-normative] The consumer may have to virtually unwind to the
    call site (see 6.4 Call Frame Information) in order to evaluate
    these attributes. This will ensure the source language thread of
    execution upon which the user is focused corresponds to the call
    site needed to evaluate the expression.

    If it is not possible to avoid the expressions of these attributes
    from accessing registers or memory locations that might be clobbered
    by the subprogram being called by the call site, then the associated
    attribute should not be provided.

    [non-normative] The reason for the restriction is that the parameter
    may need to be accessed during the execution of the callee. The
    consumer may virtually unwind from the called subprogram back to the
    caller and then evaluate the attribute expressions. The call frame
    information (see 6.4 Call Frame Information) will not be able to
    restore registers that have been clobbered, and clobbered memory
    will no longer have the value at the time of the call.
    --------------------------------------------------------------------

In Section 4.1 Data Object Entries, replace item 4 (DW_AT_location) with
the following:

    --------------------------------------------------------------------
    Any debugging information entry describing a data object (which
    includes variables and parameters) or common blocks may have a
    DW_AT_location attribute, whose value is a DWARF expression E.

    The result of the attribute is obtained by evaluating E with a
    context that has a result kind of a location description, an
    unspecified object, the compilation unit that contains E, an empty
    initial stack, and other context elements corresponding to the
    source language thread of execution upon which the user is focused,
    if any. The result of the evaluation is the location description of
    the base of the data object.

    See 2.5.4.2 Control Flow Operations for special evaluation rules
    used by the DW_OP_call* operations.

    > [For further discussion...]
    > NOTE: Delete the description of how the DW_OP_call* operations
    > evaluate a DW_AT_location attribute as that is now described in
    > the operations.
    >
    > NOTE: See the discussion about the DW_AT_location attribute in the
    > DW_OP_call* operation. Having each attribute only have a single
    > purpose and single execution semantics seems desirable. It makes
    > it easier for the consumer that no longer have to track the
    > context. It makes it easier for the producer as it can rely on a
    > single semantics for each attribute.
    >
    > For that reason, limiting the DW_AT_location attribute to only
    > supporting evaluating the location description of an object, and
    > using a different attribute and encoding class for the evaluation
    > of DWARF expression procedures on the same operation expression
    > stack seems desirable.
    --------------------------------------------------------------------

> [For further discussion]
> With respect to item 10 (DW_AT_const_value): Could deprecate using the
> DW_AT_const_value attribute for DW_TAG_variable or
> DW_TAG_formal_parameter debugger information entries that have been
> optimized to a constant. Instead, DW_AT_location could be used with a
> DWARF expression that produces an implicit location description now
> that any location description can be used within a DWARF expression.
> This allows the DW_OP_call* operations to be used to push the location
> description of any variable regardless of how it is optimized.

In Section 5.7.3 Derived or Extended Structures, Classes and Interfaces,
in the paragraph about DW_AT_data_member_location, replace the second sentence through the end of the paragraph with the following:

    --------------------------------------------------------------------
    For a DW_AT_data_member_location attribute there are two cases:

     1. If the attribute is an integer constant B, it provides the
        offset in bytes from the beginning of the containing entity.

        The result of the attribute is obtained by updating the bit
        offset of the location description of the beginning of the
        containing entity by B scaled by 8 (the byte size). The result
        is the location description of the base of the member entry.

        [non-normative] If the beginning of the containing entity is not
        byte aligned, then the beginning of the member entry has the
        same bit displacement within a byte.

     2. Otherwise, the attribute must be a DWARF expression E which is
        evaluated with a context that has a result kind of a location
        description, an unspecified object, the compilation unit that
        contains E, an initial stack comprising the location description
        of the beginning of the containing entity, and other context
        elements corresponding to the source language thread of
        execution upon which the user is focused, if any. The result of
        the evaluation is the location description of the base of the
        member entry.

        > [For further discussion...]
        > The beginning of the containing entity can now be any location
        > description, including those with more than one single
        > location description, and those with single location
        > descriptions that are of any kind and have any bit offset.
    --------------------------------------------------------------------

In Section 5.7.8 Member Function Entries, replace the sixth paragraph,
about DW_AT_vtable_elem_location, with the following:

    --------------------------------------------------------------------
    An entry for a virtual function also has a
    DW_AT_vtable_elem_location attribute whose value is a DWARF
    expression E.

    The result of the attribute is obtained by evaluating E with a
    context that has a result kind of a location description, an
    unspecified object, the compilation unit that contains E, an initial
    stack comprising the location description of the object of the
    enclosing type, and other context elements corresponding to the
    source language thread of execution upon which the user is focused,
    if any. The result of the evaluation is the location description of
    the slot for the function within the virtual function table for the
    enclosing class.
    --------------------------------------------------------------------

In Section 5.14 Pointer to Member Type Entries, replace the sixth
through eighth paragraphs, about DW_AT_use_location, with the following:

    --------------------------------------------------------------------
    The DW_TAG_ptr_to_member_type debugging information entry has a
    DW_AT_use_location attribute whose value is a DWARF expression E. It
    is used to compute the location description of the member of the
    class to which the pointer to member entry points.

    [non-normative] The method used to find the location description of
    a given member of a class, structure, or union is common to any
    instance of that class, structure, or union and to any instance of
    the pointer to member type. The method is thus associated with the
    pointer to member type, rather than with each object that has a
    pointer to member type.

    The DW_AT_use_location DWARF expression is used in conjunction with
    the location description for a particular object of the given
    pointer to member type and for a particular structure or class
    instance.

    The result of the attribute is obtained by evaluating E with a
    context that has a result kind of a location description, an
    unspecified object, the compilation unit that contains E, an initial
    stack comprising two entries, and other context elements
    corresponding to the source language thread of execution upon which
    the user is focused, if any. The first stack entry is the value of
    the pointer to member object itself. The second stack entry is the
    location description of the base of the entire class, structure, or
    union instance containing the member whose location is being
    calculated. The result of the evaluation is the location description
    of the member of the class to which the pointer to member entry points.
    --------------------------------------------------------------------

In Section 5.16 Dynamic Type Entries, append the following at the end:

    --------------------------------------------------------------------
    The DW_AT_data_location attribute may be used with any type that
    provides one or more levels of hidden indirection and/or run-time
    parameters in its representation. Its value is a DWARF operation
    expression E which computes the location description of the data for
    an object. When this attribute is omitted, the location description
    of the data is the same as the location description of the object.

    The result of the attribute is obtained by evaluating E with a
    context that has a result kind of a location description, an object
    that is the location description of the data descriptor, the
    compilation unit that contains E, an empty initial stack, and other
    context elements corresponding to the source language thread of
    execution upon which the user is focused, if any. The result of the
    evaluation is the location description of the base of the member
    entry.

    [non-normative] E will typically involve an operation expression
    that begins with a DW_OP_push_object_address operation which loads
    the location description of the object which can then serve as a
    descriptor in subsequent calculation.

    > [For further discussion...]
    > NOTE: Since DW_AT_data_member_location, DW_AT_use_location, and
    > DW_AT_vtable_elem_location allow both operation expressions and
    > location list expressions, why does DW_AT_data_location not allow
    > both? In all cases they apply to data objects so less likely that
    > optimization would cause different operation expressions for
    > different program location ranges. But if supporting for some then
    > should be for all.
    >
    > It seems odd this attribute is not the same as
    > DW_AT_data_member_location in having an initial stack with the
    > location description of the object since the expression has to
    > need it.
    --------------------------------------------------------------------

